# -*- coding: utf-8 -*-
"""Clustering_KMeans.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pgKB3h_u_t_OIFOINboVqWkmfE78iT3v
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing libraries
from sklearn.cluster import KMeans
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from matplotlib import pyplot as plt
# %matplotlib inline
import numpy as np
import seaborn as sns

# Google drive link for the pre-processed dataframe CSV file
! gdown --id 1CiVjAMtFZoOAVzQS6tOi1I6Fr3AkVzqR

#importing pre-processed dataset
dataset = pd.read_csv("/content/Updated_CSV.csv")

# A backup copy
dataset_copy = pd.read_csv("/content/Updated_CSV.csv")

# Dataframe check

dataset.head()

#Check for null/missing values
dataset.isnull().values.any()

#Using Scaler to Standardize the following Columns: Discount, Current_price and likes_count
scaler = MinMaxScaler()

scaler.fit(dataset[['raw_price']])
dataset['raw_price'] = scaler.transform(dataset[['raw_price']])

scaler.fit(dataset[['discount']])
dataset['discount'] = scaler.transform(dataset[['discount']])

scaler.fit(dataset[['current_price']])
dataset['current_price'] = scaler.transform(dataset[['current_price']])

#scaler.fit(dataset[['likes_count']])
#dataset['likes_count'] = scaler.transform(dataset[['likes_count']])

# Dropping columns that are object type
dataset = dataset.drop(columns=['name','is_new','category','subcategory','codCountry'])

# Determining the number of clusters using the Elbow Method
inertia = []
k_rng = range(1,10)
for k in k_rng:
    km = KMeans(n_clusters=k)
    km.fit(dataset[['likes_count', 'discount', 'current_price']])
    inertia.append(km.inertia_)

# Ploting Elbow Graph
plt.xlabel('Number of Clusters')
plt.ylabel('Inertia')
plt.plot(k_rng,inertia)

# Checking dataset after drop and scaling
dataset.head()

# Using KMeans Cluster
km = KMeans(n_clusters=3)
y_predicted = km.fit_predict(dataset[['likes_count', 'discount', 'current_price']])
y_predicted

# Creating a new column to store the cluster data
dataset['cluster']=y_predicted

dataset

km.cluster_centers_

# Dispplay the scatter plots for the data points in each cluster showing relationship between discount and likes_count for each cluster
dataset1 = dataset[dataset.cluster==0]
dataset2 = dataset[dataset.cluster==1]
dataset3 = dataset[dataset.cluster==2]
plt.scatter(dataset1.discount,dataset1.likes_count,color='green')
plt.scatter(dataset2.discount,dataset2.likes_count,color='red')
plt.scatter(dataset3.discount,dataset3.likes_count,color='black')
plt.xlabel('Discount')
plt.ylabel('Likes')
plt.legend()

# Dispplay the scatter plots for the data points in each cluster showing relationship between likes_count and current_price for each cluster
plt.scatter(dataset1.likes_count,dataset1.current_price,color='green')
plt.scatter(dataset2.likes_count,dataset2.current_price,color='red')
plt.scatter(dataset3.likes_count,dataset3.current_price,color='black')

plt.xlabel('Likes Count')
plt.ylabel('Current Price')
plt.legend()

# Dispplay the scatter plots for the data points in each cluster showing relationship between discount and current_price for each cluster
plt.scatter(dataset1.discount,dataset1.current_price,color='green')
plt.scatter(dataset2.discount,dataset2.current_price,color='red')
plt.scatter(dataset3.discount,dataset3.current_price,color='black')
plt.xlabel('Discount')
plt.ylabel('Current Price')
plt.legend()

# Adding the cluster column to the dataset for analysis
dataset_copy['cluster'] = y_predicted

dataset_copy

# Analyzing the top 10 data of Cluster 0
# Filter the dataset for cluster 0
cluster_0_products = dataset_copy[dataset_copy['cluster'] == 0]

# Sort the filtered data by 'likes_count' in descending order
cluster_0 = cluster_0_products.sort_values(by='likes_count', ascending=False).head(10)

# Display the top 10 products
cluster_0

# Analyzing the top 10 products of Cluster 1
# Filter the dataset for cluster 1
cluster_1_products = dataset_copy[dataset_copy['cluster'] == 1]

# Sort the filtered data by 'likes_count' in descending order
cluster_1 = cluster_1_products.sort_values(by='likes_count', ascending=False).head(10)

# Display the top 10 products
cluster_1

## Analyzing the 10 data of Cluster 2
# Filter the dataset for cluster 2
cluster_2_products = dataset_copy[dataset_copy['cluster'] == 2]

# Sort the filtered data by 'likes_count' in descending order
cluster_2 = cluster_2_products.sort_values(by='likes_count', ascending=False).head(10)

# Display the top 10 products
cluster_2

# Filter the dataset for All 3 cluster
cluster_all_products = dataset_copy

# Sort the filtered data by 'likes_count' in descending order
top_10_cluster = cluster_all_products.sort_values(by='likes_count', ascending=False).head(10)

# Display the top 10 products
top_10_cluster

# Create a box plot to display the discount range for each cluster
plt.figure(figsize=(7, 6))
sns.boxplot(
    x='cluster',
    y='discount',
    data=dataset_copy,
    palette='Set1'
)

# Set the labels and title
plt.xlabel('Cluster')
plt.ylabel('Discount')
plt.title('Product Discount Range for Each Cluster')

# Improve layout and show the plot
plt.tight_layout()
plt.show()

# Top 10 products from each category

# Initialize a DataFrame to store the top 10 products from each category
top_10_products_each_category = pd.DataFrame()

# get the top 10 products in each category
for category, group in dataset_copy.groupby('category'):
    # Sort the products in the current category by 'likes_count' in descending order
    top_10 = group.sort_values(by='likes_count', ascending=False).head(10)


    top_10_products_each_category = pd.concat([top_10_products_each_category, top_10])


top_10_products_each_category = top_10_products_each_category.reset_index(drop=True)

# Display the top 10 products from each category
top_10_products_each_category[['name', 'current_price', 'discount', 'category', 'likes_count', 'cluster']]

# Count the number of products in each cluster
cluster_counts = top_10_products_each_category['cluster'].value_counts()

# Create a bar plot for the number of products in each cluster
plt.figure(figsize=(7, 6))
sns.barplot(x=cluster_counts.index, y=cluster_counts.values, palette='viridis')

# Set plot labels and title
plt.xlabel('Cluster')
plt.ylabel('Number of Products')
plt.title('Number of Products in Each Cluster (Top 10 from each category)')

# Show the plot
plt.tight_layout()
plt.show()

# Find the top 10 products across all categories based on likes_count
top_10_products_all_categories = dataset_copy.nlargest(10, 'likes_count')

# Display the top 10 products
top_10_products_all_categories[['name', 'current_price', 'discount', 'category', 'likes_count', 'cluster']]

#Top 10 products featuring at least 1 product from each category


# Group by category and select the top 2 products from each category based on likes_count
top_2_per_category = dataset_copy.groupby('category').apply(lambda x: x.nlargest(2, 'likes_count')).reset_index(drop=True)

# Select at least one product from each category
top_per_category = top_2_per_category.groupby('category').apply(lambda x: x.nlargest(1, 'likes_count')).reset_index(drop=True)

# If we need more products to reach 10, find the additional products
remaining_slots = 10 - len(top_per_category)

if remaining_slots > 0:
    # Remove the already selected products to avoid duplicates
    remaining_products = top_2_per_category[~top_2_per_category.index.isin(top_per_category.index)]

    # Select the additional products based on likes_count
    additional_products = remaining_products.nlargest(remaining_slots, 'likes_count')

    # Combine the selected products with the additional ones
    top_10_products = pd.concat([top_per_category, additional_products])
else:
    top_10_products = top_per_category

# Display the top 10 products
top_10_products[['name', 'current_price', 'discount', 'category', 'likes_count', 'cluster']]

import pandas as pd


# # Get the top 100 products and their categories
top_100_products = dataset_copy.nlargest(100, 'likes_count')

# Display the top 1000 products
top_100_products[['name', 'current_price','discount','category','likes_count', 'cluster']]

import seaborn as sns

# Count the number of products in each cluster
cluster_counts = top_100_products['cluster'].value_counts()

# Create a bar plot for the number of products in each cluster
plt.figure(figsize=(8, 5))
sns.barplot(x=cluster_counts.index, y=cluster_counts.values, palette='viridis')

# Set plot labels and title
plt.xlabel('Cluster')
plt.ylabel('Number of Products')
plt.title('Number of Products in Each Cluster (Top 100 products)')

# Show the plot
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Assuming dataset_copy already has the necessary data

# Get the top 100 products based on likes_count
top_100_products = dataset_copy.nlargest(100, 'likes_count')

# Count the number of products in each category and cluster
category_cluster_counts = top_100_products.groupby(['category', 'cluster']).size().unstack(fill_value=0)

# Create a grouped bar chart
category_cluster_counts.plot(kind='bar', stacked=False, figsize=(7, 6), colormap='Set1')

# Set the labels and title
plt.xlabel('Category')
plt.ylabel('Number of Products')
plt.title('Number of Products in Each Category by Cluster (For Top 100 Products)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=45, ha='right')

# Display the plot
plt.tight_layout()
plt.show()

# Display the top 100 products and their categories
# Create a plot
plt.figure(figsize=(8, 5))


sns.countplot(
    y='category',
    data=top_100_products,
    palette='viridis'
)

# Set plot labels and title
plt.xlabel('Count')
plt.ylabel('Category')
plt.title('Categories of Top 100 Products')

# Show the plot
plt.tight_layout()
plt.show()

# Filter the dataset to get the top 100 products based on likes_count


# Create a plot
plt.figure(figsize=(8, 5))


sns.countplot(
    y='category',
    data=top_10_products_all_categories,
    palette='viridis'
)

# Set plot labels and title
plt.xlabel('Count')
plt.ylabel('Category')
plt.title('Categories of Top 10 Products')

# Show the plot
plt.tight_layout()
plt.show()

from sklearn.metrics import silhouette_score

# Initialize a dictionary to store the silhouette score for each category
silhouette_scores_by_category = {}

# Get unique categories from the dataset
categories = dataset_copy['category'].unique()

for category in categories:
    # Filter the dataset for the current category
    category_data = dataset_copy[dataset_copy['category'] == category]

    if len(category_data['cluster'].unique()) > 1:  # Silhouette score requires at least 2 clusters
        # Calculate the Silhouette Score for the current category
        score = silhouette_score(category_data[['likes_count', 'discount', 'current_price']], category_data['cluster'])
        silhouette_scores_by_category[category] = score
    else:
        silhouette_scores_by_category[category] = float('nan')  # Not enough clusters to calculate a score

# Display silhouette scores for each category
for category, score in silhouette_scores_by_category.items():
    print(f"Silhouette Score for Category '{category}': {score}")

silhouette_scores_df = pd.DataFrame(list(silhouette_scores_by_category.items()), columns=['Category', 'Silhouette Score'])

# Plot a bar chart for the Silhouette Scores by category
plt.figure(figsize=(7, 6))
plt.bar(silhouette_scores_df['Category'], silhouette_scores_df['Silhouette Score'], color='skyblue')

# Set the labels and title
plt.ylabel('Silhouette Score')
plt.xlabel('Category')
plt.title('Silhouette Scores by Category (K Means Clustering Algorithm)')

# Rotate category names for better readability
plt.xticks(rotation=45, ha='right')

# Display the plot
plt.tight_layout()
plt.show()